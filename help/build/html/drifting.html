<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Drifting Risk Calculations &#8212; OMRAT 0.3.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=ff28a369" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=b5312e80" />
    <script src="_static/documentation_options.js?v=4621528c"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Ship-Ship Collision Calculations" href="collisions.html" />
    <link rel="prev" title="Mathematical Foundations" href="theory.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">OMRAT</a></h1>



<p class="blurb">Open Maritime Risk Analysis Tool - QGIS Plugin</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=axelande&repo=OMRAT&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Project Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_guide.html">User Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory &amp; Calculations</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="theory.html">Mathematical Foundations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Drifting Risk Calculations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#blackout-probability">Blackout Probability</a></li>
<li class="toctree-l2"><a class="reference internal" href="#repair-time-distribution">Repair Time Distribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#drift-corridor-generation">Drift Corridor Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#probability-integration">Probability Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wind-rose-weighting">Wind Rose Weighting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#final-drifting-risk">Final Drifting Risk</a></li>
<li class="toctree-l2"><a class="reference internal" href="#computational-complexity">Computational Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#result-visualisation">Result Visualisation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="collisions.html">Ship-Ship Collision Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="powered.html">Powered Grounding and Allision</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Code Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="theory.html" title="previous chapter">Mathematical Foundations</a></li>
      <li>Next: <a href="collisions.html" title="next chapter">Ship-Ship Collision Calculations</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="drifting-risk-calculations">
<span id="drifting"></span><h1>Drifting Risk Calculations<a class="headerlink" href="#drifting-risk-calculations" title="Link to this heading">¶</a></h1>
<p>This chapter describes how OMRAT calculates the risk of ships that lose
propulsion (blackout) and drift into obstacles such as shallow water
(grounding) or structures (allision). Drifting risk is the most
computationally intensive part of the risk assessment, involving
geometric corridor construction, obstacle shadow modelling, and Monte
Carlo probability integration.</p>
<nav class="contents local" id="in-this-chapter">
<p class="topic-title">In this chapter</p>
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id3">Overview</a></p></li>
<li><p><a class="reference internal" href="#blackout-probability" id="id4">Blackout Probability</a></p></li>
<li><p><a class="reference internal" href="#repair-time-distribution" id="id5">Repair Time Distribution</a></p></li>
<li><p><a class="reference internal" href="#drift-corridor-generation" id="id6">Drift Corridor Generation</a></p>
<ul>
<li><p><a class="reference internal" href="#step-1-base-surface" id="id7">Step 1: Base Surface</a></p></li>
<li><p><a class="reference internal" href="#step-2-projection-distance" id="id8">Step 2: Projection Distance</a></p></li>
<li><p><a class="reference internal" href="#step-3-projected-corridor" id="id9">Step 3: Projected Corridor</a></p></li>
<li><p><a class="reference internal" href="#step-4-obstacle-shadows-the-quad-sweep-algorithm" id="id10">Step 4: Obstacle Shadows (The Quad-Sweep Algorithm)</a></p></li>
<li><p><a class="reference internal" href="#step-5-corridor-clipping" id="id11">Step 5: Corridor Clipping</a></p></li>
<li><p><a class="reference internal" href="#step-6-anchor-zone-split" id="id12">Step 6: Anchor Zone Split</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#probability-integration" id="id13">Probability Integration</a></p>
<ul>
<li><p><a class="reference internal" href="#why-monte-carlo" id="id14">Why Monte Carlo?</a></p></li>
<li><p><a class="reference internal" href="#the-algorithm" id="id15">The Algorithm</a></p></li>
<li><p><a class="reference internal" href="#vectorised-ray-polygon-intersection" id="id16">Vectorised Ray-Polygon Intersection</a></p></li>
<li><p><a class="reference internal" href="#multi-obstacle-cascading" id="id17">Multi-Obstacle Cascading</a></p></li>
<li><p><a class="reference internal" href="#performance-optimisations" id="id18">Performance Optimisations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#wind-rose-weighting" id="id19">Wind Rose Weighting</a></p></li>
<li><p><a class="reference internal" href="#final-drifting-risk" id="id20">Final Drifting Risk</a></p></li>
<li><p><a class="reference internal" href="#computational-complexity" id="id21">Computational Complexity</a></p></li>
<li><p><a class="reference internal" href="#result-visualisation" id="id22">Result Visualisation</a></p></li>
</ul>
</nav>
<section id="overview">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Overview</a><a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>When a ship suffers a blackout (engine failure), it becomes powerless
and drifts under the influence of wind and current. The drifting risk
calculation determines the probability that a drifting ship will reach
an obstacle before:</p>
<ol class="arabic simple">
<li><p>The crew repairs the engine, or</p></li>
<li><p>The crew deploys the anchor (in sufficiently shallow water)</p></li>
</ol>
<p>The overall drifting accident probability for a single leg is:</p>
<div class="math notranslate nohighlight">
\[P_{\text{drift}} = \sum_{d=1}^{8}
  W_d \times P_{\text{hit},d} \times (1 - P_{\text{repair},d})
  \times (1 - P_{\text{anchor},d}) \times P_C\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(W_d\)</span> = wind rose probability for direction <span class="math notranslate nohighlight">\(d\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P_{\text{hit},d}\)</span> = geometric probability of hitting obstacle
from direction <span class="math notranslate nohighlight">\(d\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P_{\text{repair},d}\)</span> = probability of engine repair before
reaching obstacle</p></li>
<li><p><span class="math notranslate nohighlight">\(P_{\text{anchor},d}\)</span> = probability of successful anchoring</p></li>
<li><p><span class="math notranslate nohighlight">\(P_C\)</span> = causation factor (1.0 for drifting – no avoidance
possible without power)</p></li>
</ul>
<p>The following figure shows a complete example with drift corridors in
all 8 compass directions, with realistic irregular obstacles and
blocking zones:</p>
<a class="reference internal image-reference" href="_images/drift_corridor_visualization.png"><img alt="Example drift corridors with 8 directions, obstacles, and blocking zones" src="_images/drift_corridor_visualization.png" style="width: 100%;" />
</a>
<p>The coloured regions represent the reachable area for each wind
direction after obstacle blocking has been applied. The grey rectangle
at the centre is the base surface around the shipping leg, and the blue
irregular shapes are depth obstacles. Notice how the corridors are
clipped where they encounter obstacles, and how gaps between scattered
obstacle parts remain open – ships can drift through them.</p>
<div class="source-code-ref pipeline docutils container">
<p><strong>Pipeline orchestrator:</strong> <code class="docutils literal notranslate"><span class="pre">compute/drifting_model.py:975</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/compute/drifting_model.py#L975">run_drifting_model()</a> |
<strong>Corridor generator:</strong> <code class="docutils literal notranslate"><span class="pre">geometries/drift/generator.py:25</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/geometries/drift/generator.py#L25">DriftCorridorGenerator</a></p>
</div>
</section>
<section id="blackout-probability">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Blackout Probability</a><a class="headerlink" href="#blackout-probability" title="Link to this heading">¶</a></h2>
<p>The probability that a ship experiences a blackout while transiting a
leg segment is modelled as a Poisson process:</p>
<div class="math notranslate nohighlight">
\[P_{\text{blackout}} = 1 - \exp\!\left(
  -\frac{F_b}{24 \times 365} \times h
\right)\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F_b\)</span> = blackout frequency (events per year)</p></li>
<li><p><span class="math notranslate nohighlight">\(h\)</span> = transit time across the leg (hours)</p></li>
<li><p><span class="math notranslate nohighlight">\(h = L / V\)</span> (leg length divided by ship speed)</p></li>
</ul>
<div class="source-code-ref docutils container">
<p><code class="docutils literal notranslate"><span class="pre">compute/basic_equations.py:9</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/compute/basic_equations.py#L9">get_drifting_prob()</a></p>
</div>
</section>
<section id="repair-time-distribution">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Repair Time Distribution</a><a class="headerlink" href="#repair-time-distribution" title="Link to this heading">¶</a></h2>
<p>The time required to repair a blackout is modelled using a <strong>lognormal
distribution</strong>:</p>
<div class="math notranslate nohighlight">
\[P(\text{repaired by time } t) = F_{\text{lognorm}}(t; \sigma, \mu_{\text{loc}}, s)\]</div>
<p>Where the parameters are:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\sigma\)</span> = shape parameter (standard deviation of log)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mu_{\text{loc}}\)</span> = location parameter</p></li>
<li><p><span class="math notranslate nohighlight">\(s\)</span> = scale parameter (<code class="docutils literal notranslate"><span class="pre">exp(mean</span> <span class="pre">of</span> <span class="pre">log)</span></code>)</p></li>
</ul>
<p>The probability that the ship is <strong>not</strong> repaired before drifting a
distance <span class="math notranslate nohighlight">\(d\)</span> is:</p>
<div class="math notranslate nohighlight">
\[P_{\text{not repaired}} = 1 - F_{\text{lognorm}}\!\left(
  \frac{d}{V_{\text{drift}} \times 3600}
\right)\]</div>
<p>Where the drift time is <span class="math notranslate nohighlight">\(d / V_{\text{drift}}\)</span> converted to hours.</p>
<div class="source-code-ref docutils container">
<p><code class="docutils literal notranslate"><span class="pre">compute/basic_equations.py:30</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/compute/basic_equations.py#L30">get_not_repaired()</a> |
<code class="docutils literal notranslate"><span class="pre">compute/basic_equations.py:18</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/compute/basic_equations.py#L18">repairtime_function()</a></p>
</div>
<p>Default parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">0.95</span></code> (shape)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loc</span> <span class="pre">=</span> <span class="pre">0.2</span></code> (location)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">=</span> <span class="pre">0.85</span></code> (scale)</p></li>
</ul>
<p>Users can also define a custom repair time function using a Python
expression.</p>
</section>
<section id="drift-corridor-generation">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Drift Corridor Generation</a><a class="headerlink" href="#drift-corridor-generation" title="Link to this heading">¶</a></h2>
<p>The drift corridor is the central geometric construct in OMRAT’s
drifting risk model. It represents the area that ships could drift
through from a given shipping leg, in a given wind direction, before
their engines are repaired. The corridor must account for:</p>
<ul class="simple">
<li><p>The <strong>lateral spread</strong> of ship starting positions (traffic distribution)</p></li>
<li><p>The <strong>maximum drift distance</strong> (from the repair time distribution)</p></li>
<li><p>The <strong>blocking effect</strong> of obstacles (ships cannot drift through land
or structures)</p></li>
<li><p>The <strong>anchoring opportunity</strong> in shallow water</p></li>
</ul>
<p>Building these corridors correctly is non-trivial. Real-world obstacles
are irregular polygons derived from bathymetric data (GEBCO depth
contours) or manually digitised structures. They can be scattered
MultiPolygons with gaps, concave shapes, or overlapping features. The
corridor generation must handle all of these cases while preserving
geometric fidelity.</p>
<p>The following diagram illustrates the complete 6-step construction
process:</p>
<a class="reference internal image-reference" href="_images/corridor_construction.svg"><img alt="Drift corridor construction walkthrough (6 steps)" src="_images/corridor_construction.svg" style="width: 100%;" />
</a>
<section id="step-1-base-surface">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Step 1: Base Surface</a><a class="headerlink" href="#step-1-base-surface" title="Link to this heading">¶</a></h3>
<p>A rectangle is created perpendicular to the leg, representing the
starting positions of ships on the leg. Its width is derived from the
lateral traffic distribution:</p>
<div class="math notranslate nohighlight">
\[\text{width} = 2 \times Z_{0.995} \times \sigma_{\text{lateral}}\]</div>
<p>Where <span class="math notranslate nohighlight">\(Z_{0.995} \approx 2.576\)</span> is the normal quantile for 99%
coverage. This means the base surface captures 99% of the lateral
traffic distribution. Ships outside this range are extremely unlikely
and their contribution to the risk integral is negligible.</p>
<p>The rectangle has four corners computed from the leg’s start/end points,
extended perpendicularly by <code class="docutils literal notranslate"><span class="pre">half_width</span></code> in both directions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">perp_dir</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">leg_dir_y</span><span class="p">,</span> <span class="n">leg_dir_x</span><span class="p">]</span>   <span class="p">(</span><span class="mi">90</span><span class="o">-</span><span class="n">degree</span> <span class="n">rotation</span><span class="p">)</span>
<span class="n">B1</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">half_width</span> <span class="o">*</span> <span class="n">perp_dir</span>
<span class="n">B2</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">half_width</span> <span class="o">*</span> <span class="n">perp_dir</span>
<span class="n">B3</span> <span class="o">=</span> <span class="n">end</span>   <span class="o">+</span> <span class="n">half_width</span> <span class="o">*</span> <span class="n">perp_dir</span>
<span class="n">B4</span> <span class="o">=</span> <span class="n">end</span>   <span class="o">-</span> <span class="n">half_width</span> <span class="o">*</span> <span class="n">perp_dir</span>
</pre></div>
</div>
<div class="source-code-ref docutils container">
<p><code class="docutils literal notranslate"><span class="pre">geometries/drift/corridor.py:16</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/geometries/drift/corridor.py#L16">create_base_surface()</a></p>
</div>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text">Base surface corner calculation (geometries/drift/corridor.py)</span><a class="headerlink" href="#id1" title="Link to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">leg</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Polygon</span><span class="p">()</span>

    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">leg_vec</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">leg_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">leg_vec</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">leg_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Polygon</span><span class="p">()</span>

    <span class="c1"># Calculate perpendicular direction</span>
    <span class="n">leg_dir</span> <span class="o">=</span> <span class="n">leg_vec</span> <span class="o">/</span> <span class="n">leg_length</span>
    <span class="n">perp_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">leg_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">leg_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="c1"># Create rectangle corners</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">half_width</span> <span class="o">*</span> <span class="n">perp_dir</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">half_width</span> <span class="o">*</span> <span class="n">perp_dir</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">end</span> <span class="o">+</span> <span class="n">half_width</span> <span class="o">*</span> <span class="n">perp_dir</span>
    <span class="n">p4</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">half_width</span> <span class="o">*</span> <span class="n">perp_dir</span>

    <span class="k">return</span> <span class="n">Polygon</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">])</span>
</pre></div>
</div>
</div>
</section>
<section id="step-2-projection-distance">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Step 2: Projection Distance</a><a class="headerlink" href="#step-2-projection-distance" title="Link to this heading">¶</a></h3>
<p>The maximum drift distance determines how far the corridor extends. It
is calculated from the repair time distribution by finding the time at
which 99.9% of blackouts would have been repaired, then converting to
distance:</p>
<div class="math notranslate nohighlight">
\[t_{99.9\%} = F^{-1}_{\text{lognorm}}(0.999)\]</div>
<div class="math notranslate nohighlight">
\[d_{\text{max}} = t_{99.9\%} \times 3600 \times V_{\text{drift}}\]</div>
<p>This gives the distance at which only 0.1% of ships would still be
drifting. Beyond this distance, the risk contribution is negligible. The
distance is clamped to [10 km, 50 km] as a sanity bound.</p>
<p>For the default parameters (std=0.95, loc=0.2, scale=0.85) and a drift
speed of 1.94 knots (~1 m/s), the projection distance is approximately
58 km.</p>
<div class="source-code-ref docutils container">
<p><code class="docutils literal notranslate"><span class="pre">geometries/drift/distribution.py:13</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/geometries/drift/distribution.py#L13">get_projection_distance()</a></p>
</div>
</section>
<section id="step-3-projected-corridor">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Step 3: Projected Corridor</a><a class="headerlink" href="#step-3-projected-corridor" title="Link to this heading">¶</a></h3>
<p>The base surface is “swept” along the drift direction by the projection
distance. Concretely:</p>
<ol class="arabic simple">
<li><p>Translate all four base corners by the drift vector</p></li>
<li><p>Create a polygon from the translated corners (the “projected surface”)</p></li>
<li><p>Take the convex hull of the union of base + projected surface</p></li>
</ol>
<p>The drift vector is computed from the compass angle:</p>
<div class="math notranslate nohighlight">
\[\theta_{\text{math}} = 90° + \theta_{\text{compass}}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\vec{v}_{\text{drift}} = d_{\text{max}} \times
\begin{pmatrix}
  \cos(\theta_{\text{math}}) \\
  \sin(\theta_{\text{math}})
\end{pmatrix}\end{split}\]</div>
<p>The convex hull ensures a single simple polygon. For cardinal directions
(N, S, E, W), the result is a rectangle. For diagonal directions (NE,
NW, SE, SW), it is a parallelogram.</p>
<div class="source-code-ref docutils container">
<p><code class="docutils literal notranslate"><span class="pre">geometries/drift/corridor.py:54</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/geometries/drift/corridor.py#L54">create_projected_corridor()</a></p>
</div>
</section>
<section id="step-4-obstacle-shadows-the-quad-sweep-algorithm">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Step 4: Obstacle Shadows (The Quad-Sweep Algorithm)</a><a class="headerlink" href="#step-4-obstacle-shadows-the-quad-sweep-algorithm" title="Link to this heading">¶</a></h3>
<p>When a corridor intersects an obstacle, a <strong>shadow zone</strong> (blocking
zone) is created behind the obstacle. Ships cannot drift through solid
obstacles, so the area downwind of the obstacle is unreachable from the
leg.</p>
<p>Creating accurate shadow zones is the most geometrically challenging
step. The naive approach of taking the convex hull of the obstacle and
its translated copy fails for <strong>concave obstacles</strong> – it fills in gaps
that ships could actually drift through. This is a critical problem
because real bathymetric data often produces irregular, concave depth
contours.</p>
<p>OMRAT uses a <strong>quad-based sweep algorithm</strong> that preserves the exact
contour of the obstacle:</p>
<a class="reference internal image-reference" href="_images/shadow_algorithm.svg"><img alt="Quad-sweep shadow algorithm detail" src="_images/shadow_algorithm.svg" style="width: 100%;" />
</a>
<p>The algorithm works as follows:</p>
<ol class="arabic">
<li><p><strong>Translate the obstacle</strong> along the drift direction by a large
distance (twice the corridor diagonal). This creates a “far copy”
that extends well beyond the corridor boundary.</p></li>
<li><p><strong>Create edge quads</strong>: For each edge of the obstacle polygon (defined
by consecutive vertices <span class="math notranslate nohighlight">\(v_i\)</span> and <span class="math notranslate nohighlight">\(v_{i+1}\)</span>), create a
quadrilateral connecting the original edge to the corresponding
translated edge:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Quad_i</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([</span> <span class="n">v_i</span><span class="p">,</span> <span class="n">v_</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">v</span><span class="s1">&#39;_(i+1), v&#39;</span><span class="n">_i</span> <span class="p">])</span>
</pre></div>
</div>
<p>An obstacle with N vertices produces N quads.</p>
</li>
<li><p><strong>Union everything</strong>: The shadow is the union of the original
obstacle, all N quads, and the translated copy.</p></li>
</ol>
<p><strong>Why quads instead of convex hull?</strong></p>
<p>Consider a C-shaped obstacle (e.g., a reef with a navigable channel
through the middle):</p>
<ul class="simple">
<li><p><strong>Convex hull</strong> fills the channel – ships are incorrectly blocked
from drifting through the gap</p></li>
<li><p><strong>Quad-sweep</strong> preserves the channel – each edge of the C-shape
generates its own quad, and the interior gap remains open</p></li>
</ul>
<p>This distinction is critical for real bathymetric data, where depth
contours often have irregular shapes with navigable gaps between
scattered shallow patches.</p>
<p><strong>MultiPolygon handling</strong>: Real depth data frequently consists of
multiple disconnected polygons (e.g., a reef system with several
separated shoals). OMRAT handles this by:</p>
<ol class="arabic simple">
<li><p>Intersecting the obstacle with the corridor</p></li>
<li><p>Extracting individual polygon parts from the intersection</p></li>
<li><p>Creating a separate shadow for <strong>each part</strong></p></li>
<li><p>Taking the union of all shadows</p></li>
</ol>
<p>This ensures that gaps between obstacle parts remain open for drift.</p>
<div class="source-code-ref docutils container">
<p><code class="docutils literal notranslate"><span class="pre">geometries/drift/shadow.py:18</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/geometries/drift/shadow.py#L18">create_obstacle_shadow()</a> |
<code class="docutils literal notranslate"><span class="pre">geometries/drift/shadow.py:96</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/geometries/drift/shadow.py#L96">_create_edge_quads()</a></p>
</div>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text">Quad-sweep core logic (geometries/drift/shadow.py)</span><a class="headerlink" href="#id2" title="Link to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
        <span class="c1"># Get coordinates for quad construction</span>
        <span class="n">original_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obstacle</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Exclude closing point</span>
        <span class="n">translated_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">far_obstacle</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Fallback for degenerate obstacles</span>
            <span class="k">return</span> <span class="n">unary_union</span><span class="p">([</span><span class="n">obstacle</span><span class="p">,</span> <span class="n">far_obstacle</span><span class="p">])</span><span class="o">.</span><span class="n">convex_hull</span>

        <span class="c1"># Create quads connecting each edge of original to corresponding edge of translated</span>
        <span class="n">quads</span> <span class="o">=</span> <span class="n">_create_edge_quads</span><span class="p">(</span><span class="n">original_coords</span><span class="p">,</span> <span class="n">translated_coords</span><span class="p">)</span>

        <span class="c1"># Union the original obstacle, all quads, and far obstacle</span>
        <span class="n">all_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">obstacle</span><span class="p">,</span> <span class="n">far_obstacle</span><span class="p">]</span> <span class="o">+</span> <span class="n">quads</span>
        <span class="n">shadow</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">all_parts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="step-5-corridor-clipping">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Step 5: Corridor Clipping</a><a class="headerlink" href="#step-5-corridor-clipping" title="Link to this heading">¶</a></h3>
<p>The corridor is clipped by subtracting all shadow zones:</p>
<div class="math notranslate nohighlight">
\[\text{Corridor}_{\text{clipped}} = \text{Corridor}_{\text{full}}
- \bigcup_i \text{Shadow}_i\]</div>
<p>Only the <strong>reachable</strong> parts of the corridor remain – areas that can
be reached from the upwind edge without passing through any obstacle.</p>
<p>After clipping, the result may be a MultiPolygon (e.g., if an obstacle
cuts the corridor in two). OMRAT applies a <strong>reachability filter</strong>:
only polygon parts that touch the upwind edge of the corridor are kept.
The upwind edge is the edge opposite to the drift direction – it is
where ships enter the corridor.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Drift North (0°)  --&gt; upwind edge = South edge (min_y)
Drift East (270°) --&gt; upwind edge = West edge (min_x)
Drift West (90°)  --&gt; upwind edge = East edge (max_x)
etc.
</pre></div>
</div>
<p>Fragments that are disconnected from the upwind edge are discarded, as
no ship can reach them without passing through an obstacle first.</p>
<div class="source-code-ref docutils container">
<p><code class="docutils literal notranslate"><span class="pre">geometries/drift/clipping.py:16</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/geometries/drift/clipping.py#L16">clip_corridor_at_obstacles()</a></p>
</div>
</section>
<section id="step-6-anchor-zone-split">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Step 6: Anchor Zone Split</a><a class="headerlink" href="#step-6-anchor-zone-split" title="Link to this heading">¶</a></h3>
<p>The clipped corridor is split into two zones based on water depth:</p>
<ul class="simple">
<li><p><strong>Anchorable zone</strong> (blue): Areas where the water depth is less than
the maximum anchorable depth (<span class="math notranslate nohighlight">\(d &lt; d_{\text{anchor}}\)</span>). Ships
in these areas can attempt anchoring with probability
<span class="math notranslate nohighlight">\(P_{\text{anchor}}\)</span>.</p></li>
<li><p><strong>Deep water zone</strong> (green): Areas too deep for anchoring. Ships must
wait for engine repair.</p></li>
</ul>
<p>A subtle but important rule applies: <strong>areas behind (downwind of) an
anchor zone are reclassified as anchorable</strong>. The reasoning is that a
ship drifting through shallow water had the opportunity to anchor there.
If it continues drifting (anchor failed or not attempted), it has
already passed through the anchorable region. This is implemented by
creating shadow zones from the anchorable polygon parts and using them
to reclassify deep-water areas behind them.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">blue</span>  <span class="o">=</span> <span class="n">corridor_clipped</span> <span class="n">AND</span> <span class="n">anchor_polygon</span>
<span class="n">green</span> <span class="o">=</span> <span class="n">corridor_clipped</span> <span class="o">-</span> <span class="n">anchor_polygon</span>

<span class="n">blue_shadows</span> <span class="o">=</span> <span class="n">union</span> <span class="n">of</span> <span class="n">shadows</span> <span class="kn">from</span> <span class="nn">each</span> <span class="n">blue</span> <span class="n">part</span>
<span class="n">green_behind_blue</span> <span class="o">=</span> <span class="n">green</span> <span class="n">AND</span> <span class="n">blue_shadows</span>

<span class="n">final_blue</span>  <span class="o">=</span> <span class="n">blue</span> <span class="o">+</span> <span class="n">green_behind_blue</span>
<span class="n">final_green</span> <span class="o">=</span> <span class="n">green</span> <span class="o">-</span> <span class="n">blue_shadows</span>
</pre></div>
</div>
<div class="source-code-ref docutils container">
<p><code class="docutils literal notranslate"><span class="pre">geometries/drift/clipping.py:124</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/geometries/drift/clipping.py#L124">split_corridor_by_anchor_zone()</a></p>
</div>
</section>
</section>
<section id="probability-integration">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Probability Integration</a><a class="headerlink" href="#probability-integration" title="Link to this heading">¶</a></h2>
<p>Once the drift corridors are generated, OMRAT computes the probability
that a ship starting from any position on the leg will drift into each
obstacle. This uses <strong>Monte Carlo integration</strong> – a numerical method
well-suited to the high-dimensional, irregular geometry of the problem.</p>
<a class="reference internal image-reference" href="_images/monte_carlo_integration.svg"><img alt="Monte Carlo probability integration algorithm" src="_images/monte_carlo_integration.svg" style="width: 100%;" />
</a>
<section id="why-monte-carlo">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Why Monte Carlo?</a><a class="headerlink" href="#why-monte-carlo" title="Link to this heading">¶</a></h3>
<p>The probability integral has the form:</p>
<div class="math notranslate nohighlight">
\[P = \int_0^{L} \frac{1}{L} \int_{-W/2}^{+W/2}
    f(y) \cdot I_{\text{hit}}(s, y, d) \, dy \, ds\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(s\)</span> = position along the leg (0 to L)</p></li>
<li><p><span class="math notranslate nohighlight">\(y\)</span> = lateral offset from the leg centreline</p></li>
<li><p><span class="math notranslate nohighlight">\(f(y)\)</span> = lateral traffic distribution (mixture of normals)</p></li>
<li><p><span class="math notranslate nohighlight">\(I_{\text{hit}}(s, y, d)\)</span> = indicator function: 1 if a ship at
position <span class="math notranslate nohighlight">\((s, y)\)</span> drifting in direction <span class="math notranslate nohighlight">\(d\)</span> hits the
obstacle, 0 otherwise</p></li>
</ul>
<p>The indicator function depends on whether a ray from the starting
position, cast in the drift direction, intersects the obstacle polygon.
This makes the integrand discontinuous (a step function), which is
poorly suited to quadrature methods but well-suited to Monte Carlo
sampling.</p>
<p>Analytical integration would require decomposing the obstacle boundary
into segments and computing exact intersection intervals – feasible for
simple rectangles, but impractical for irregular real-world polygons
with dozens of vertices. Monte Carlo integration handles arbitrary
polygon shapes with no special-case logic.</p>
</section>
<section id="the-algorithm">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">The Algorithm</a><a class="headerlink" href="#the-algorithm" title="Link to this heading">¶</a></h3>
<p>For each combination of (leg, direction, obstacle):</p>
<ol class="arabic">
<li><p><strong>Sample N random points</strong> <span class="math notranslate nohighlight">\((s_k, y_k)\)</span> where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(s_k \sim \text{Uniform}(0, 1)\)</span> – position along the leg</p></li>
<li><p><span class="math notranslate nohighlight">\(y_k \sim \text{Uniform}(-W/2, +W/2)\)</span> – lateral offset</p></li>
</ul>
</li>
<li><p><strong>Compute the starting position</strong> for each sample:</p>
<div class="math notranslate nohighlight">
\[\vec{p}_0 = \vec{p}_{\text{start}} + s_k \cdot \vec{v}_{\text{leg}}
           + y_k \cdot \vec{n}_{\perp}\]</div>
</li>
<li><p><strong>Cast a ray</strong> in the drift direction:</p>
<div class="math notranslate nohighlight">
\[\vec{p}_1 = \vec{p}_0 + d_{\text{max}} \cdot \hat{v}_{\text{drift}}\]</div>
</li>
<li><p><strong>Test ray-polygon intersection</strong>: Determine whether the ray from
<span class="math notranslate nohighlight">\(\vec{p}_0\)</span> to <span class="math notranslate nohighlight">\(\vec{p}_1\)</span> intersects the obstacle
polygon. This uses a vectorised parametric intersection test (see
below).</p></li>
<li><p><strong>Weight hits by the lateral PDF</strong>: For each ray that hits the
obstacle, evaluate the combined lateral distribution:</p>
<div class="math notranslate nohighlight">
\[f(y_k) = \sum_i w_i \cdot \phi\!\left(\frac{y_k - \mu_i}{\sigma_i}\right)\]</div>
</li>
<li><p><strong>Estimate the probability</strong>:</p>
<div class="math notranslate nohighlight">
\[P \approx \frac{W}{N} \sum_{k \in \text{hits}} f(y_k)\]</div>
<p>Where <span class="math notranslate nohighlight">\(W = 2 \times W_{\text{half}}\)</span> is the total lateral
integration width. The result is normalised by leg length to give
a per-unit-length probability.</p>
</li>
</ol>
<div class="source-code-ref docutils container">
<p><code class="docutils literal notranslate"><span class="pre">geometries/calculate_probability_holes.py:642</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/geometries/calculate_probability_holes.py#L642">compute_probability_holes()</a></p>
</div>
</section>
<section id="vectorised-ray-polygon-intersection">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Vectorised Ray-Polygon Intersection</a><a class="headerlink" href="#vectorised-ray-polygon-intersection" title="Link to this heading">¶</a></h3>
<p>The ray-polygon intersection test is the innermost loop of the Monte
Carlo integration and must be fast. OMRAT uses a <strong>vectorised numpy
implementation</strong> that tests all N rays against all edges of the polygon
simultaneously.</p>
<p>For a ray <span class="math notranslate nohighlight">\(P(t) = \vec{p}_0 + t (\vec{p}_1 - \vec{p}_0)\)</span> and an
edge <span class="math notranslate nohighlight">\(Q(s) = \vec{e}_0 + s (\vec{e}_1 - \vec{e}_0)\)</span>, intersection
occurs when both <span class="math notranslate nohighlight">\(t \in [0,1]\)</span> and <span class="math notranslate nohighlight">\(s \in [0,1]\)</span>. The
parameters are found by solving:</p>
<div class="math notranslate nohighlight">
\[t = \frac{(\vec{e}_0 - \vec{p}_0) \times (\vec{e}_1 - \vec{e}_0)}
         {(\vec{p}_1 - \vec{p}_0) \times (\vec{e}_1 - \vec{e}_0)}\]</div>
<p>Where <span class="math notranslate nohighlight">\(\times\)</span> denotes the 2D cross product
<span class="math notranslate nohighlight">\((a_x b_y - a_y b_x)\)</span>. The cross products for all N rays and all
E edges are computed in batch using numpy array operations, yielding a
~3x speedup over per-ray Shapely intersection calls.</p>
<p>A <strong>bounding box pre-filter</strong> skips obstacle rings whose bounding box
does not overlap the ray’s bounding box, avoiding unnecessary
computation for distant obstacles.</p>
</section>
<section id="multi-obstacle-cascading">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Multi-Obstacle Cascading</a><a class="headerlink" href="#multi-obstacle-cascading" title="Link to this heading">¶</a></h3>
<p>When multiple obstacles exist, they are processed in <strong>distance order</strong>
(nearest to the leg first). Each obstacle’s shadow reduces the corridor
available for subsequent obstacles. This prevents double-counting: if
obstacle A blocks the path to obstacle B, then B’s contribution is
reduced accordingly.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">corridor_remaining</span> <span class="o">=</span> <span class="n">full_corridor</span>

<span class="k">for</span> <span class="n">obstacle</span> <span class="ow">in</span> <span class="n">sorted_by_distance_from_leg</span><span class="p">:</span>
    <span class="n">P</span><span class="p">[</span><span class="n">obstacle</span><span class="p">]</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">corridor_remaining</span><span class="p">,</span> <span class="n">obstacle</span><span class="p">)</span>
    <span class="n">shadow</span> <span class="o">=</span> <span class="n">create_shadow</span><span class="p">(</span><span class="n">obstacle</span><span class="p">)</span>
    <span class="n">corridor_remaining</span> <span class="o">=</span> <span class="n">corridor_remaining</span> <span class="o">-</span> <span class="n">shadow</span>

    <span class="k">if</span> <span class="n">cumulative_probability</span> <span class="o">&gt;=</span> <span class="mf">0.99</span><span class="p">:</span>
        <span class="k">break</span>   <span class="c1"># Early termination</span>
</pre></div>
</div>
<p>This cascading model ensures that the sum of probabilities across all
obstacles does not exceed 1.0. The early termination criterion avoids
wasting computation on distant obstacles that contribute negligibly to
the total risk.</p>
</section>
<section id="performance-optimisations">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Performance Optimisations</a><a class="headerlink" href="#performance-optimisations" title="Link to this heading">¶</a></h3>
<p>The Monte Carlo integration is the computational bottleneck of OMRAT.
For a typical analysis with 10 legs, 50 obstacles, and 8 directions,
the system must perform approximately 2 million ray-polygon intersection
tests. Several optimisations make this feasible:</p>
<ul class="simple">
<li><p><strong>Parallel execution</strong>: <code class="docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code> with
<code class="docutils literal notranslate"><span class="pre">cpu_count</span> <span class="pre">-</span> <span class="pre">1</span></code> workers processes (leg, direction) pairs
concurrently</p></li>
<li><p><strong>Early termination</strong>: Skip remaining obstacles once cumulative
probability exceeds 0.99</p></li>
<li><p><strong>Distance rejection</strong>: Skip obstacles too far to be reachable within
the projection distance</p></li>
<li><p><strong>Batch ray testing</strong>: Vectorised numpy ray-polygon intersection (~3x
faster than per-ray Shapely calls)</p></li>
<li><p><strong>Adaptive sampling</strong>: 500 samples for the first obstacles, reduced
to 300 (cumulative P &gt; 0.8) or 200 (cumulative P &gt; 0.95) for later
obstacles that contribute less to the total</p></li>
</ul>
</section>
</section>
<section id="wind-rose-weighting">
<h2><a class="toc-backref" href="#id19" role="doc-backlink">Wind Rose Weighting</a><a class="headerlink" href="#wind-rose-weighting" title="Link to this heading">¶</a></h2>
<p>The probability from each of the 8 directions is weighted by the wind
rose probability. The wind rose defines the fraction of time that winds
blow from each direction:</p>
<div class="math notranslate nohighlight">
\[P_{\text{total}} = \sum_{d=1}^{8} W_d \times P_d\]</div>
<p>Where <span class="math notranslate nohighlight">\(W_d\)</span> is the wind rose probability and <span class="math notranslate nohighlight">\(\sum W_d = 1\)</span>.</p>
<p>The default wind rose assigns equal probability (12.5%) to all 8
directions. Users can adjust these values based on local meteorological
data. In practice, the wind rose has a large impact on the final risk:
if the dominant wind direction pushes ships toward an obstacle, the risk
is much higher than for a wind direction that pushes ships into open
water.</p>
</section>
<section id="final-drifting-risk">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">Final Drifting Risk</a><a class="headerlink" href="#final-drifting-risk" title="Link to this heading">¶</a></h2>
<p>The complete drifting risk formula for obstacle <span class="math notranslate nohighlight">\(j\)</span> from leg
<span class="math notranslate nohighlight">\(i\)</span> is:</p>
<div class="math notranslate nohighlight">
\[R_{ij} = \sum_{d=1}^{8} W_d \times P_{\text{hit},ijd}
\times P_{\text{blackout},i}
\times (1 - P_{\text{repair},ijd})
\times (1 - P_{\text{anchor},ijd})
\times \sum_k Q_{ik} \cdot P_C\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Q_{ik}\)</span> = traffic frequency for ship type <span class="math notranslate nohighlight">\(k\)</span> on leg
<span class="math notranslate nohighlight">\(i\)</span> (ships/year)</p></li>
<li><p>All other symbols as defined above</p></li>
</ul>
<p>The total drifting risk is the sum over all legs and obstacles.</p>
</section>
<section id="computational-complexity">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Computational Complexity</a><a class="headerlink" href="#computational-complexity" title="Link to this heading">¶</a></h2>
<p>The drift corridor pipeline has the following computational profile:</p>
<p><strong>Corridor generation</strong> (per leg, per direction):</p>
<ul class="simple">
<li><p>Base surface: O(1) – 4 corner points</p></li>
<li><p>Projection: O(1) – translation + convex hull of 8 points</p></li>
<li><p>Shadow creation: O(M x E) – M obstacles with E edges each</p></li>
<li><p>Corridor clipping: O(M x E<sup>2</sup>) – polygon difference with
union of M shadows (the expensive step)</p></li>
<li><p>Anchor splitting: O(E) – intersection and shadow extension</p></li>
</ul>
<p><strong>Probability integration</strong> (per leg, per direction):</p>
<ul class="simple">
<li><p>Per obstacle: O(N x E) – N sample rays tested against E edges</p></li>
<li><p>Typical: N = 500 samples, E = 10–100 edges</p></li>
<li><p>Total per (leg, direction): O(M x N x E)</p></li>
</ul>
<p><strong>Full analysis</strong> (L legs, M obstacles, 8 directions):</p>
<ul class="simple">
<li><p>Corridor generation: O(L x 8 x M x E<sup>2</sup>) – dominated by
clipping</p></li>
<li><p>Probability integration: O(L x 8 x M x N x E) – dominated by ray
tests</p></li>
</ul>
<p>For a medium-sized analysis (L=10, M=50, N=500, E=20), this amounts to
~4 million ray-edge intersection tests, which typically completes in
1–5 minutes depending on hardware. Larger analyses (L=50, M=200) may
take 30 minutes or more; the QGIS Task Manager shows progress during
execution.</p>
</section>
<section id="result-visualisation">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">Result Visualisation</a><a class="headerlink" href="#result-visualisation" title="Link to this heading">¶</a></h2>
<p>Drifting risk results are visualised as QGIS vector layers:</p>
<ul class="simple">
<li><p><strong>Allision results</strong>: Line segments along structure boundaries, coloured
by probability (green = low, red = high)</p></li>
<li><p><strong>Grounding results</strong>: Line segments along depth contours, coloured by
probability</p></li>
<li><p><strong>Drift corridors</strong>: Polygon layers per leg, categorised by wind
direction with transparent colour coding</p></li>
</ul>
<p>Each obstacle segment’s exposure is weighted by the angle between the
segment’s outward normal and the drift direction:</p>
<div class="math notranslate nohighlight">
\[\text{exposure} = \max(0, \cos(\theta_{\text{diff}}))\]</div>
<p>Where <span class="math notranslate nohighlight">\(\theta_{\text{diff}}\)</span> is the angular difference between the
drift direction and the segment’s hit direction (normal + 180 deg).</p>
<div class="source-code-ref docutils container">
<p><code class="docutils literal notranslate"><span class="pre">geometries/result_layers.py</span></code> – <a class="reference external" href="https://github.com/axelande/OMRAT/blob/main/geometries/result_layers.py">create_result_layers()</a></p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2022-2026, Axel Hörteborn / RISE.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/drifting.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>